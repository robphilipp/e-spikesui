import * as React from 'react'
import {useEffect, useRef, useState} from 'react'
import {defaultCustomThemes, DefaultTheme} from './themes';
import {RouteComponentProps, useHistory, useParams, useRouteMatch, withRouter} from "react-router-dom";
import {AppState} from "../redux/reducers/root";
import {ThunkDispatch} from "redux-thunk";
import {ApplicationAction} from "../redux/actions/actions";
import {connect} from "react-redux";
import {
    IconButton,
    ITheme,
    Layer,
    LayerHost,
    MessageBar,
    MessageBarType,
    Separator,
    Stack,
    TooltipHost
} from '@fluentui/react';
import {
    loadSensorsFrom,
    loadSensorsFromTemplate,
    saveSensors as persistEnvironment,
    SensorsLoadedAction,
    SensorsSavedAction,
    updateSensors,
} from "../redux/actions/sensors";
import {KeyboardShortcut, keyboardShortcutFor} from "./keyboardShortcuts";
import {remote} from "electron";
import MonacoEditor from "./MonacoEditor";
import {Observable, Subscription} from "rxjs";
import {SensorOutput} from "../sensors/compiler";
import SensorSimulation from "../sensors/SensorSimulation";
import {map} from "rxjs/operators";
import {ChartData, Datum} from "stream-charts";
import moment from 'moment';
import {baseRouterPathFrom} from '../router/router';
import {ModuleProxy, PrivateThreadProps, StripAsync} from "threads/dist/types/master";
import {ObservablePromise} from "threads/dist/observable-promise";
import {newSensorThread, SensorThread} from '../threads/SensorThread';

type SimulationType = (((...args: any) => ObservablePromise<StripAsync<SensorOutput>>) & PrivateThreadProps & ModuleProxy<any>);

export const NEW_SENSOR_PATH = '**new**';

export enum ExpressionState {
    PRE_COMPILED = 'pre-compiled',
    COMPILED = 'compiled',
    RUNNING = 'running'
}

const customThemes = defaultCustomThemes();
const editorOptions = {selectOnLineNumbers: true, scrollBeyondLastLine: false};
const emptyFunction = () => {
    return;
}

const SIDEBAR_WIDTH = 32;
const SIDEBAR_ELEMENT_HEIGHT = 32;

interface Dimension {
    height: number;
    width: number;
}

interface OwnProps extends RouteComponentProps<never> {
    itheme: ITheme;
    theme?: string;
}

interface StateProps {
    codeSnippet: string;
    modified: boolean;
    sensorDescriptionPath?: string;
    templatePath?: string;
}

interface DispatchProps {
    onChanged: (description: string) => void;
    onLoadTemplate: (path: string) => Promise<SensorsLoadedAction>;
    onLoadSensor: (path: string) => Promise<SensorsLoadedAction>;
    onSave: (path: string, description: string) => Promise<SensorsSavedAction>;
}

type Props = StateProps & DispatchProps & OwnProps;

/**
 * The sensor editor allows the user to write a sensor code-snippet and run a test simulation
 * to see the timing as a raster chart.
 * @param props Properties form the parent, redux state, and dispatchers
 * @return Screen that holds the sensor code-snippet editor and sensor simulation output
 */
function SensorsEditor(props: Props): JSX.Element {
    const {
        theme = DefaultTheme.DARK,
        itheme,
        codeSnippet,
        templatePath,
        onChanged,
        onLoadTemplate,
        onLoadSensor,
        onSave,
        modified,
        sensorDescriptionPath,
    } = props;

    // when user refreshes when the router path is this editor, then we want to load the same
    // sensor as before the refresh. to do this we use the path parameter holding the file path
    // to the sensor code-snippet, and keep it consistent when loading from template
    const {sensorsPath} = useParams<{ [key: string]: string }>();
    const history = useHistory();
    const {path} = useRouteMatch();

    const [baseRouterPath, setBaseRouterPath] = useState<string>(baseRouterPathFrom(path));

    const editorRef = useRef<HTMLDivElement>();
    const [dimension, setDimension] = useState<Dimension>({width: 50, height: 50});
    const heightFractionRef = useRef(1.0);

    // // manages the state of the code snippet (i.e. pre-compiled, compiled, running), and the
    // // compile-time errors
    // const [expressionState, setExpressionState] = useState<ExpressionState>(ExpressionState.PRE_COMPILED);
    // const [expressionError, setExpressionError] = useState<string>();
    // // a reference to the observable generated by compiling and executing the sensor description
    // const [sensorObservable, setSensorObservable] = useState<Observable<SensorOutput>>();
    // const [chartObservable, setChartObservable] = useState<Observable<ChartData>>();
    // const [neuronIds, setNeuronIds] = useState<Array<string>>();
    // // a reference to the subscription to the observable used for testing
    // const subscriptionRef = useRef<Subscription>();
    const [showSimulation, setShowSimulation] = useState(false);

    const [message, setMessage] = useState<JSX.Element>();

    // // sensor thread
    // const sensorThreadRef = useRef<SensorThread>();

    // when component mounts, sets the initial dimension of the editor and registers to listen
    // to window resize events. when component un-mounts, removes the window-resize event listener
    useEffect(
        () => {
            if (editorRef.current) {
                setDimension(editorDimensions());
            }

            // // create a sensor-simulation worker for compiling and running the sensor
            // newSensorThread().then(thread => sensorThreadRef.current = thread);

            // listen to resize events so that the editor width and height can be updated
            window.addEventListener('resize', handleWindowResize);

            return () => {
                // stop listening to resize events
                window.removeEventListener('resize', handleWindowResize);

                // // terminate sensor-simulation worker thread
                // sensorThreadRef.current.terminate();
            }
        },
        []
    );

    // when the environment code-snippet file path from the router has changed, and is
    // not equal to the current state path, or is empty, then load the environment code-snippet,
    // or a template
    useEffect(
        () => {
            const filePath = decodeURIComponent(sensorsPath);
            if (filePath === sensorDescriptionPath) {
                return;
            }
            if (filePath === NEW_SENSOR_PATH || filePath === 'undefined') {
                onLoadTemplate(templatePath)
                    .then(() => console.log("loaded"))
                    .catch(reason => setMessage(errorMessage(reason.message)))
            } else {
                // todo handle success and failure
                onLoadSensor(filePath)
                    .then(() => console.log("loaded"))
                    .catch(reason => setMessage(errorMessage(reason.message)))
            }
        },
        [sensorsPath]
    );

    // // the keyboard event listener holds a stale ref to the props, so we need to update
    // // the referenced values when they change. Also when the code snippet changes, then
    // // we need to set the observableRef back to an undefined
    // useEffect(
    //     () => {
    //         setSensorObservable(undefined);
    //         setExpressionState(ExpressionState.PRE_COMPILED);
    //     },
    //     [sensorDescriptionPath, templatePath, codeSnippet]
    // );

    // recalculate the base path when the path changes (note that the base path won't change)
    useEffect(
        () => {
            setBaseRouterPath(baseRouterPathFrom(path));
        },
        [path]
    )

    /**
     * calculates the editors dimensions based on the `<div>`'s width and height
     * @return The dimension of the editor
     */
    function editorDimensions(): Dimension {
        return {
            width: editorRef.current.offsetWidth,
            height: editorRef.current.clientHeight * heightFractionRef.current
        };
    }

    /**
     * updates the editor's width and height when the container's dimensions change
     */
    function handleWindowResize(): void {
        if (editorRef.current) {
            const nextDimension = editorDimensions()
            const minDiff = 2;
            if (Math.abs(nextDimension.height - dimension.height) > minDiff ||
                Math.abs(nextDimension.width - dimension.width) > minDiff) {
                setDimension(nextDimension);
            }
        }
    }

    /**
     * Handles keyboard events when the editor is focused
     * @param event The keyboard event
     */
    function handleKeyboardShortcut(event: React.KeyboardEvent<HTMLDivElement>): void {
        keyboardShortcutFor(event.nativeEvent).ifSome(shortcut => {
            switch (shortcut) {
                case KeyboardShortcut.NEW:
                    handleNew();
                    break;

                case KeyboardShortcut.SAVE: {
                    handleSave(sensorDescriptionPath, templatePath, codeSnippet);
                    break;
                }

                case KeyboardShortcut.LOAD:
                    handleLoad();
                    break;

                default:
                /* nothing to do */
            }
        });
    }

    /**
     * Handles loading a new network from a template file.
     */
    function handleNew(): void {
        onLoadTemplate(templatePath)
            .then(() => history.push(`${baseRouterPath}/${encodeURIComponent(templatePath)}`))
    }

    /**
     * Handles saving the file when the path exists, otherwise opens a save-file dialog to allow
     * the user to set the path. Sends redux action when file has been saved.
     */
    function handleSave(path: string, templatePath: string, network: string): void {
        // if the state path is set and the path does not equal the template path, then the network
        // description is from an existing file, and we can just save it. otherwise, we need to up a
        // dialog so that the user can give the filename
        if (path && path !== templatePath) {
            // todo handle success and error
            onSave(path, network).then(() => console.log('saved'));
        } else {
            remote.dialog
                .showSaveDialog(remote.getCurrentWindow(), {title: "Save As..."})
                .then(response => onSave(response.filePath, network)
                    .then(() => history.push(`${baseRouterPath}/${encodeURIComponent(response.filePath)}`))
                );
        }
    }

    /**
     * Handle loading a sensor description from file by presenting the user with an open-file
     * dialog.
     */
    function handleLoad(): void {
        remote.dialog
            .showOpenDialog(
                remote.getCurrentWindow(),
                {
                    title: 'Open...',
                    filters: [{name: 'spikes-sensor', extensions: ['sensor']}],
                    properties: ['openFile']
                }
            )
            .then(response => {
                history.push(`${baseRouterPath}/${encodeURIComponent(response.filePaths[0])}`);
            })
    }

    // /**
    //  * Handles compiling and evaluating the sensor description code-snippet. The compiled code snippet
    //  * is for simulating the sensor code so that it can be tested.
    //  * @return An empty promise
    //  */
    // async function handleCompile(): Promise<void> {
    //     setMessage(undefined);
    //
    //     // compile the code-snippet as a simulator
    //     const generator = await sensorThreadRef.current.compileSimulator(codeSnippet);
    //
    //     setNeuronIds(generator.neuronIds);
    //     setSensorObservable(generator.observable);
    //     setExpressionState(ExpressionState.COMPILED);
    // }
    //
    // /**
    //  * Handles running the simulation by subscribing to the observable generated from compiling the
    //  * sensor code snippet.
    //  */
    // function handleRunSensorSimulation(): void {
    //     if (expressionState === ExpressionState.COMPILED) {
    //         const now = moment().valueOf();
    //         const observable = sensorObservable.pipe(
    //             map(output => ({
    //                 maxTime: output.time - now,
    //                 newPoints: new Map<string, Array<Datum>>(
    //                     output.neuronIds.map(id => [id, [{time: output.time - now, value: output.signal.value}]])
    //                 )
    //             }))
    //         );
    //         setChartObservable(observable);
    //         setExpressionState(ExpressionState.RUNNING);
    //         showSimulationLayer();
    //     }
    // }
    //
    // /**
    //  * Handles stopping the sensor simulation, but keeps the simulation window open
    //  */
    // function handleStopSensorSimulation(): void {
    //     subscriptionRef.current?.unsubscribe();
    //     // only want to set the expression state to compiled if it is running. it is possible
    //     // that the simulation has been stopped (expression state is compiled), and then edited
    //     // while the simulation window is open, and in that case, we want to leave the expression
    //     // state as pre-compiled
    //     if (expressionState === ExpressionState.RUNNING) {
    //         sensorThreadRef.current.stop();
    //         setSensorObservable(undefined);
    //         setExpressionState(ExpressionState.PRE_COMPILED);
    //     }
    // }

    // /**
    //  * Handles hiding the sensor simulation output. Stops the simulation if it is running.
    //  */
    // function handleHideSimulation(): void {
    //     handleStopSensorSimulation();
    //     hideSimulationLayer();
    // }

    /**
     * Sets the state so that the sensor simulation window is visible
     */
    function showSimulationLayer(): void {
        heightFractionRef.current = 0.5;
        setDimension(editorDimensions());
        setShowSimulation(true);
    }

    /**
     * Sets the state so that the sensor simulation window is hidden
     */
    function hideSimulationLayer(): void {
        heightFractionRef.current = 1.0;
        setDimension(editorDimensions());
        setShowSimulation(false);
    }

    /**
     * Create a button to create a new network
     * @return a button to create a new network
     */
    function newButton(): JSX.Element {
        return <div style={{width: SIDEBAR_WIDTH, height: SIDEBAR_ELEMENT_HEIGHT}}>
            <TooltipHost content="New network environment from template">
                <IconButton
                    iconProps={{iconName: 'add'}}
                    onClick={() => handleNew()}
                />
            </TooltipHost>
        </div>
    }

    /**
     * Creates a save button in the gutter when the contents have an associated file
     * path, and when they can be saved.
     * @return The save-button component
     */
    function saveButton(): JSX.Element {
        return <div style={{width: SIDEBAR_WIDTH, height: SIDEBAR_ELEMENT_HEIGHT}}>
            <TooltipHost content="Save network environment">
                <IconButton
                    iconProps={{iconName: 'save'}}
                    onClick={() => handleSave(sensorDescriptionPath, templatePath, codeSnippet)}
                    disabled={!(modified || sensorDescriptionPath === templatePath)}
                />
            </TooltipHost>
        </div>
    }

    /**
     * Presents the user with a open-file dialog for selecting a network description
     * file.
     * @return The load button for the sidebar
     */
    function loadButton(): JSX.Element {
        return <div style={{width: SIDEBAR_WIDTH, height: SIDEBAR_ELEMENT_HEIGHT}}>
            <TooltipHost content="Load network environment">
                <IconButton
                    iconProps={{iconName: 'upload'}}
                    onClick={handleLoad}
                />
            </TooltipHost>
        </div>
    }

    function showSimulationButton(): JSX.Element {
            return <div style={{width: SIDEBAR_WIDTH, height: SIDEBAR_ELEMENT_HEIGHT}}>
                <TooltipHost content="Show sensor simulation control panel">
                    <IconButton
                        iconProps={{iconName: 'sprint'}}
                        disabled={showSimulation || modified || codeSnippet?.length < 10}
                        onClick={showSimulationLayer}
                    />
                </TooltipHost>
            </div>
    }

    // /**
    //  * Creates a compile button used to compile the sensor description
    //  * @return The button for compiling the sensor description
    //  */
    // function compileButton(): JSX.Element {
    //     return <div style={{width: SIDEBAR_WIDTH, height: SIDEBAR_ELEMENT_HEIGHT}}>
    //         <TooltipHost content="Compile the sensor code">
    //             <IconButton
    //                 iconProps={{iconName: 'code'}}
    //                 disabled={
    //                     (codeSnippet !== undefined && codeSnippet.length < 31) ||
    //                     sensorObservable !== undefined ||
    //                     expressionState === ExpressionState.RUNNING ||
    //                     expressionState === ExpressionState.COMPILED
    //                 }
    //                 onClick={handleCompile}
    //             />
    //         </TooltipHost>
    //     </div>
    // }
    //
    // /**
    //  * Creates an evaluate button used to evaluate the sensor description
    //  * @return The button for evaluating the sensor description
    //  */
    // function runSensorSimulationButton(): JSX.Element {
    //     return <div style={{width: SIDEBAR_WIDTH, height: SIDEBAR_ELEMENT_HEIGHT}}>
    //         <TooltipHost content="Run simulation of the sensor code">
    //             <IconButton
    //                 iconProps={{iconName: 'sprint'}}
    //                 disabled={
    //                     expressionState === ExpressionState.PRE_COMPILED ||
    //                     expressionState === ExpressionState.RUNNING ||
    //                     expressionError !== undefined ||
    //                     sensorObservable === undefined
    //                 }
    //                 onClick={handleRunSensorSimulation}
    //             />
    //         </TooltipHost>
    //     </div>
    // }
    //
    // /**
    //  * Creates a stop button used to stop the evaluation of the sensor description code
    //  * @return The button for stopping the evaluation of the sensor description code
    //  */
    // function stopSensorSimulationButton(): JSX.Element {
    //     return <div style={{width: SIDEBAR_WIDTH, height: SIDEBAR_ELEMENT_HEIGHT}}>
    //         <TooltipHost content="Stop the sensor code simulation">
    //             <IconButton
    //                 iconProps={{iconName: 'stop'}}
    //                 disabled={expressionState !== ExpressionState.RUNNING}
    //                 onClick={handleStopSensorSimulation}
    //             />
    //         </TooltipHost>
    //     </div>
    // }
    //
    // /**
    //  * Creates the button to hide the sensor simulation layer.
    //  * @return The button for hiding the sensor simulation layer.
    //  */
    // function hideSimulationButton(): JSX.Element {
    //     return <div style={{width: SIDEBAR_WIDTH, height: SIDEBAR_ELEMENT_HEIGHT}}>
    //         <TooltipHost content="Hide the sensor simulation">
    //             <IconButton
    //                 iconProps={{iconName: 'minusCircle'}}
    //                 onClick={handleHideSimulation}
    //             />
    //         </TooltipHost>
    //     </div>
    // }

    /**
     * Message bar for displaying errors
     * @param message The error message
     * @return A `MessageBar` with an error message
     */
    function errorMessage(message: string): JSX.Element {
        return (
            <MessageBar
                messageBarType={MessageBarType.error}
                isMultiline={false}
                onDismiss={() => setMessage(undefined)}
                dismissButtonAriaLabel="Close"
            >
                {message}
            </MessageBar>
        )
    }

    return (
        <div
            ref={editorRef}
            // can't just set a fraction for the height because the parent height may not be
            // set...but if it is, then you can use that.
            style={{height: window.innerHeight * 0.9, width: '100%'}}
            onKeyDown={handleKeyboardShortcut}
        >
            {message || <span/>}
            <div
                style={{
                    marginLeft: 30,
                    marginBottom: 8,
                    height: 15,
                    color: props.itheme.palette.themeSecondary
                }}
            >
                {sensorDescriptionPath === undefined || sensorDescriptionPath === templatePath ? '[new file]' : sensorDescriptionPath}{modified ? '*' : ''}
            </div>
            <Stack horizontal>
                <Stack.Item>
                    {newButton()}
                    {saveButton()}
                    {loadButton()}
                    <Separator/>
                    {showSimulationButton()}
                    {/*{compileButton()}*/}
                    {/*{runSensorSimulationButton()}*/}
                    {/*{stopSensorSimulationButton()}*/}
                    {/*{showSimulation && hideSimulationButton()}*/}
                </Stack.Item>
                <Stack>
                    <Stack.Item>
                        <MonacoEditor
                            editorId='spikes-env'
                            width={dimension.width}
                            height={dimension.height}
                            language="javascript"
                            theme={theme}
                            customThemes={customThemes}
                            value={codeSnippet}
                            options={editorOptions}
                            onChange={onChanged}
                            editorDidMount={emptyFunction}
                        />
                        {showSimulation && <LayerHost id='chart-layer'/>}
                    </Stack.Item>
                </Stack>
            </Stack>
            {showSimulation &&
            <Layer hostId="chart-layer">
                <Separator>Sensor Simulation</Separator>
                <SensorSimulation
                    itheme={itheme}
                    codeSnippet={codeSnippet}
                    onClose={hideSimulationLayer}
                    // neuronIds={neuronIds}
                    // observable={chartObservable}
                    // shouldSubscribe={expressionState === ExpressionState.RUNNING}
                    // onSubscribe={subscription => subscriptionRef.current = subscription}
                />
            </Layer>}
        </div>
    )
}

/*
 |
 |    REACT-REDUX functions and code
 |    (see also redux/actions.ts for the action types)
 |
 */
/**
 * react-redux function that maps the application state to the props used by the `App` component.
 * @param state The updated application state
 */
const mapStateToProps = (state: AppState): StateProps => ({
    codeSnippet: state.sensorDescription.codeSnippet,
    modified: state.sensorDescription.modified,
    sensorDescriptionPath: state.sensorDescription.path,
    templatePath: state.settings.sensorDescription.templatePath
});

/**
 * react-redux function that maps the event handlers to the dispatch functions. Note that in the
 * ThunkDispatch, I believe the first type is the state, the second type is the extra argument,
 * and the third type is, obviously, the action.
 * @param dispatch The redux dispatcher
 * @return The updated dispatch-properties holding the event handlers
 */
const mapDispatchToProps = (dispatch: ThunkDispatch<AppState, unknown, ApplicationAction>): DispatchProps => ({
    onChanged: (codeSnippet: string) => dispatch(updateSensors(codeSnippet)),
    onLoadTemplate: (path: string) => dispatch(loadSensorsFromTemplate(path)),
    onLoadSensor: (path: string) => dispatch(loadSensorsFrom(path)),
    onSave: (path: string, description: string) => dispatch(persistEnvironment(path, description)),
});

const connectedSensorEditor = connect(mapStateToProps, mapDispatchToProps)(SensorsEditor);

export default withRouter(connectedSensorEditor);